{
  "address": "0x828a6ac6b4c01e87219bcb442165b429a6794d7a",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract GameEnter",
              "name": "enterRoute",
              "type": "address"
            },
            {
              "internalType": "contract GameLeave",
              "name": "leaveRoute",
              "type": "address"
            },
            {
              "internalType": "contract GameCommit",
              "name": "commitRoute",
              "type": "address"
            },
            {
              "internalType": "contract GameReveal",
              "name": "revealRoute",
              "type": "address"
            }
          ],
          "internalType": "struct GameRouter.Routes",
          "name": "routes",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "commitPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revealPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "contract IERC721",
              "name": "characters",
              "type": "address"
            }
          ],
          "internalType": "struct Game.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum Game.Reason",
          "name": "reason",
          "type": "uint8"
        }
      ],
      "name": "InvalidMove",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "NotAuthorizedController",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyCharactersAreAccepted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "UnableToExitFromThisPosition",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newPosition",
          "type": "uint64"
        }
      ],
      "name": "EnteredTheGame",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "positionWhenLeaving",
          "type": "uint64"
        }
      ],
      "name": "LeftTheGame",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "uint192",
              "name": "action",
              "type": "uint192"
            }
          ],
          "indexed": false,
          "internalType": "struct Game.Action[]",
          "name": "actions",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newPosition",
          "type": "uint64"
        }
      ],
      "name": "MoveRevealed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes24",
          "name": "",
          "type": "bytes24"
        },
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "name": "commit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "name": "enter",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "leave",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "uint192",
              "name": "action",
              "type": "uint192"
            }
          ],
          "internalType": "struct Game.Action[]",
          "name": "",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "reveal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "GameRouter",
  "sourceName": "src/game/GameRouter.sol",
  "bytecode": "0x6101803461017e576105ae38819003601f8101601f191683016001600160401b0381118482101761018257839282916040528339810103906101009182811261017e576080811261017e57610052610196565b825190916001600160a01b0391828116810361017e578352602084015190828216820361017e5760208401918252604085015193838516850361017e5760408101948552606086015191848316830361017e5760809060608301938452607f19011261017e576100c0610196565b916080870151835260a0870151936020840194855260e060c08901519860408601998a52015196868816880361017e5786809492818094606089019b8c525116608052511660a052511660c052511660e05251855251926101209384525191610140928352511690610160918252604051926103f894856101b68639608051856101c0015260a0518561020b015260c05185610102015260e0518561017a015251846102be015251836102e20152518261030b0152518161033c0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b60405190608082016001600160401b038111838210176101825760405256fe60806040526004361015610011575f80fd5b5f3560e01c8063150b7a021461006457806394e434ec1461005f578063e826d0281461005a578063ea3b9ba1146100555763f29953b714610050575f80fd5b6101ed565b6101a7565b61012f565b6100d6565b346100c15760803660031901126100c1576100806004356100c5565b61008b6024356100c5565b6064356001600160401b038082116100c157366023830112156100c15781600401359081116100c15736910160240111156101be575b5f80fd5b6001600160a01b038116036100c157565b60603660031901126100c1576024356001600160401b03198116036100c1576101006044356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b346100c15760603660031901126100c1576001600160401b036024358181116100c157366023820112156100c15780600401359182116100c157602490369260061b0101116100c1577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b60403660031901126100c1576101be6024356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b346100c15760403660031901126100c1576102096024356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b608081019081106001600160401b0382111761025357604052565b634e487b7160e01b5f52604160045260245ffd5b601f909101601f19168101906001600160401b0382119082101761025357604052565b5f809181606060405161029c81610238565b82815282602082015282604082015201528160026040516102bc81610238565b7f00000000000000000000000000000000000000000000000000000000000000008082527f000000000000000000000000000000000000000000000000000000000000000060208084019182527f000000000000000000000000000000000000000000000000000000000000000060408086019182526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660609788019081528251948501968752945191840191909152905194820194909452905190921660808084019190915282529061039b60a082610267565b36848037518091365e8036019060f01b815201915af43d5f803e156103be573d5ff35b3d5ffdfea2646970667358221220b705a85d5082d98b3011d1b74ede732643982a3979d5d4cc4a52d53aa8b5fe9a64736f6c63430008190033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c8063150b7a021461006457806394e434ec1461005f578063e826d0281461005a578063ea3b9ba1146100555763f29953b714610050575f80fd5b6101ed565b6101a7565b61012f565b6100d6565b346100c15760803660031901126100c1576100806004356100c5565b61008b6024356100c5565b6064356001600160401b038082116100c157366023830112156100c15781600401359081116100c15736910160240111156101be575b5f80fd5b6001600160a01b038116036100c157565b60603660031901126100c1576024356001600160401b03198116036100c1576101006044356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b346100c15760603660031901126100c1576001600160401b036024358181116100c157366023820112156100c15780600401359182116100c157602490369260061b0101116100c1577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b60403660031901126100c1576101be6024356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b346100c15760403660031901126100c1576102096024356100c5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661028a565b608081019081106001600160401b0382111761025357604052565b634e487b7160e01b5f52604160045260245ffd5b601f909101601f19168101906001600160401b0382119082101761025357604052565b5f809181606060405161029c81610238565b82815282602082015282604082015201528160026040516102bc81610238565b7f00000000000000000000000000000000000000000000000000000000000000008082527f000000000000000000000000000000000000000000000000000000000000000060208084019182527f000000000000000000000000000000000000000000000000000000000000000060408086019182526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660609788019081528251948501968752945191840191909152905194820194909452905190921660808084019190915282529061039b60a082610267565b36848037518091365e8036019060f01b815201915af43d5f803e156103be573d5ff35b3d5ffdfea2646970667358221220b705a85d5082d98b3011d1b74ede732643982a3979d5d4cc4a52d53aa8b5fe9a64736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "events": {
      "CommitmentMade(uint256,address,uint24,bytes24)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "commitmentHash": "the hash of moves",
          "controller": "account handling the character moves",
          "epoch": "epoch number on which this commit belongs to"
        }
      },
      "EnteredTheGame(uint256,address,uint64)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "newPosition": "the resulting new character's position"
        }
      },
      "LeftTheGame(uint256,address,uint64)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "positionWhenLeaving": "the character's position when leaving"
        }
      },
      "MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)": {
        "params": {
          "actions": "the list of moves made",
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "epoch": "epoch number on which this commit belongs to",
          "newPosition": "the resulting new character's position"
        }
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "203200",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "commit(uint256,bytes24,address)": "infinite",
        "enter(uint256,address)": "infinite",
        "leave(uint256,address)": "infinite",
        "onERC721Received(address,address,uint256,bytes)": "infinite",
        "reveal(uint256,(uint64,uint192)[],bytes32)": "infinite"
      },
      "internal": {
        "_delegateTo(address)": "infinite",
        "_getConfig()": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract GameEnter\",\"name\":\"enterRoute\",\"type\":\"address\"},{\"internalType\":\"contract GameLeave\",\"name\":\"leaveRoute\",\"type\":\"address\"},{\"internalType\":\"contract GameCommit\",\"name\":\"commitRoute\",\"type\":\"address\"},{\"internalType\":\"contract GameReveal\",\"name\":\"revealRoute\",\"type\":\"address\"}],\"internalType\":\"struct GameRouter.Routes\",\"name\":\"routes\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"characters\",\"type\":\"address\"}],\"internalType\":\"struct Game.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Game.Reason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidMove\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotAuthorizedController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCharactersAreAccepted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"UnableToExitFromThisPosition\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newPosition\",\"type\":\"uint64\"}],\"name\":\"EnteredTheGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"positionWhenLeaving\",\"type\":\"uint64\"}],\"name\":\"LeftTheGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"action\",\"type\":\"uint192\"}],\"indexed\":false,\"internalType\":\"struct Game.Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newPosition\",\"type\":\"uint64\"}],\"name\":\"MoveRevealed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes24\",\"name\":\"\",\"type\":\"bytes24\"},{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"leave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"action\",\"type\":\"uint192\"}],\"internalType\":\"struct Game.Action[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"CommitmentMade(uint256,address,uint24,bytes24)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"commitmentHash\":\"the hash of moves\",\"controller\":\"account handling the character moves\",\"epoch\":\"epoch number on which this commit belongs to\"}},\"EnteredTheGame(uint256,address,uint64)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"newPosition\":\"the resulting new character's position\"}},\"LeftTheGame(uint256,address,uint64)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"positionWhenLeaving\":\"the character's position when leaving\"}},\"MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)\":{\"params\":{\"actions\":\"the list of moves made\",\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"newPosition\":\"the resulting new character's position\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"errors\":{\"GameNotStarted()\":[{\"notice\":\"happen when attempting to do something on a game that did not start yet\"}],\"NotAuthorizedController(address)\":[{\"notice\":\"happen when an unauthorized account attempt to control a character\"}],\"UnableToExitFromThisPosition(uint64)\":[{\"notice\":\"happen when attempting to leave the game from a non-exit position\"}]},\"events\":{\"CommitmentMade(uint256,address,uint24,bytes24)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"EnteredTheGame(uint256,address,uint64)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"LeftTheGame(uint256,address,uint64)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)\":{\"notice\":\"A character has its moves revealed and executed\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/GameRouter.sol\":\"GameRouter\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[],\"viaIR\":true},\"sources\":{\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"src/game/Game.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Game.sol\\\";\\nimport \\\"../solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\n\\nabstract contract Game {\\n    // we use constant to bound gas and allow solidity to calulate worst case scenario\\n    uint256 constant MAX_PATH_LENGTH = 256;\\n\\n    /// @notice happen when an unauthorized account attempt to control a character\\n    error NotAuthorizedController(address sender);\\n\\n    /// @notice happen when attempting to leave the game from a non-exit position\\n    error UnableToExitFromThisPosition(uint64 position);\\n\\n    /// @notice happen when attempting to do something on a game that did not start yet\\n    error GameNotStarted();\\n\\n    error OnlyCharactersAreAccepted();\\n\\n    enum Reason {\\n        None,\\n        Wall,\\n        NonAdjacent\\n    }\\n    error InvalidMove(Reason reason);\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of moves\\n    event CommitmentMade(\\n        uint256 indexed characterID,\\n        address indexed controller,\\n        uint24 indexed epoch,\\n        bytes24 commitmentHash\\n    );\\n\\n    /// @notice A character has its moves revealed and executed\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param actions the list of moves made\\n    /// @param newPosition the resulting new character's position\\n    event MoveRevealed(\\n        uint256 indexed characterID,\\n        address indexed controller,\\n        uint24 indexed epoch,\\n        Action[] actions,\\n        uint64 newPosition\\n    );\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param newPosition the resulting new character's position\\n    event EnteredTheGame(uint256 indexed characterID, address indexed controller, uint64 newPosition);\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param positionWhenLeaving the character's position when leaving\\n    event LeftTheGame(uint256 indexed characterID, address indexed controller, uint64 positionWhenLeaving);\\n\\n    struct Commitment {\\n        bytes24 hash;\\n        uint24 epoch;\\n    }\\n\\n    /// @notice Move struct that define the action, type and position\\n    struct Action {\\n        uint64 position;\\n        uint192 action; // TODO define: none, open, attack cards, etc... // TODO make position an action and remove position, first byte define the type: move,\\n    }\\n\\n    enum ControllerType {\\n        None,\\n        Basic,\\n        Owner\\n    }\\n\\n    struct CharacterState {\\n        mapping(address => ControllerType) controllers;\\n        uint64 position;\\n        uint64 epoch;\\n    }\\n\\n    struct Store {\\n        mapping(uint256 => Commitment) commitments;\\n        mapping(uint256 => CharacterState) characterStates;\\n    }\\n\\n    /// @notice Config struct to configure the game instance\\n    struct Config {\\n        uint256 startTime;\\n        uint256 commitPhaseDuration;\\n        uint256 revealPhaseDuration;\\n        IERC721 characters;\\n    }\\n\\n    struct Area {\\n        uint128 eastWalls;\\n        uint128 southWalls;\\n    }\\n\\n    enum MonsterKind {\\n        Basic\\n    }\\n\\n    struct LocalMonster {\\n        MonsterKind kind; // TODO enum\\n        int32 x;\\n        int32 y;\\n        int8 life;\\n    }\\n\\n    function getStore() internal pure returns (Store storage store) {\\n        assembly {\\n            store.slot := 0\\n        }\\n    }\\n\\n    function getConfig() internal pure returns (Config memory config) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        config = abi.decode(msg.data[offset:], (Config));\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(calldatasize(), add(shr(240, calldataload(sub(calldatasize(), 2))), 2))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55b2a039c7de3b6811641d994e35fa6c99dbe3ff5f2beac655666889761a0acd\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/GameRouter.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./routes/GameEnter.sol\\\";\\nimport \\\"./routes/GameLeave.sol\\\";\\nimport \\\"./routes/GameCommit.sol\\\";\\nimport \\\"./routes/GameReveal.sol\\\";\\n\\nimport \\\"./Game.sol\\\";\\n\\ncontract GameRouter is Game {\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    // TODO generate this automatically\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    struct Routes {\\n        GameEnter enterRoute;\\n        GameLeave leaveRoute;\\n        GameCommit commitRoute;\\n        GameReveal revealRoute;\\n    }\\n\\n    GameEnter internal immutable _route_enter;\\n    GameLeave internal immutable _route_leave;\\n    GameCommit internal immutable _route_commit;\\n    GameReveal internal immutable _route_reveal;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    // CONFIG\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    /// @notice the timestamp (in seconds) at which the game start, it start in the commit phase\\n    uint256 internal immutable START_TIME;\\n    /// @notice the duration of the commit phase in seconds\\n    uint256 internal immutable COMMIT_PHASE_DURATION;\\n    /// @notice the duration of the reveal phase in seconds\\n    uint256 internal immutable REVEAL_PHASE_DURATION;\\n    /// @notice the Character NFT Collection\\n    IERC721 internal immutable CHARACTERS;\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    constructor(Routes memory routes, Game.Config memory config) {\\n        ///////////////////////////////////////////////////////////////////////////////////////////\\n        // TODO generate this automatically\\n        ///////////////////////////////////////////////////////////////////////////////////////////\\n        _route_enter = routes.enterRoute;\\n        _route_leave = routes.leaveRoute;\\n        _route_commit = routes.commitRoute;\\n        _route_reveal = routes.revealRoute;\\n        ///////////////////////////////////////////////////////////////////////////////////////////\\n\\n        START_TIME = config.startTime;\\n        COMMIT_PHASE_DURATION = config.commitPhaseDuration;\\n        REVEAL_PHASE_DURATION = config.revealPhaseDuration;\\n        CHARACTERS = config.characters;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    // TODO generate this automatically\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    function onERC721Received(address, address, uint256, bytes calldata) external {\\n        _delegateTo(address(_route_enter));\\n    }\\n\\n    function enter(uint256, address payable) external payable {\\n        _delegateTo(address(_route_enter));\\n    }\\n\\n    function leave(uint256, address) external {\\n        _delegateTo(address(_route_leave));\\n    }\\n\\n    function commit(uint256, bytes24, address payable) external payable {\\n        _delegateTo(address(_route_commit));\\n    }\\n\\n    function reveal(uint256, Game.Action[] calldata, bytes32) external {\\n        _delegateTo(address(_route_reveal));\\n    }\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    // INTERNAL\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    function _getConfig() internal view returns (Game.Config memory) {\\n        return\\n            Game.Config({\\n                startTime: START_TIME,\\n                commitPhaseDuration: COMMIT_PHASE_DURATION,\\n                revealPhaseDuration: REVEAL_PHASE_DURATION,\\n                characters: CHARACTERS\\n            });\\n    }\\n\\n    function _delegateTo(address route) internal {\\n        bytes memory configEncoded = abi.encode(_getConfig());\\n        // taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8cab922347e79732f6a532a75da5081ba7447a71/contracts/proxy/Proxy.sol#L22-L45\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n            let confifSize := mload(configEncoded)\\n            mcopy(calldatasize(), add(configEncoded, 32), confifSize)\\n            mstore(add(calldatasize(), confifSize), shl(240, confifSize)) // max 2 bytes for size spec\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), route, 0, add(calldatasize(), add(confifSize, 2)), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x15071a0f53368ab9968423b73c0bc3ab5560eafa7e21d0844160085ee55b43d2\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/GameUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Game.sol\\\";\\nimport \\\"../utils/PositionUtils.sol\\\";\\nimport \\\"./data/Areas.sol\\\";\\n\\nlibrary GameUtils {\\n    function getEpoch(Game.Config memory config) internal view returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = config.commitPhaseDuration + config.revealPhaseDuration;\\n        uint256 time = block.timestamp; // TODO_timestamp();\\n        if (time < config.startTime) {\\n            revert Game.GameNotStarted();\\n        }\\n        uint256 timePassed = time - config.startTime;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < config.commitPhaseDuration;\\n    }\\n\\n    function computeArea(bytes32 areaHash) public pure returns (Game.Area memory) {\\n        // \\\"made only for 11x11\\\"\\n        assert(PositionUtils.AREA_SIZE == 11);\\n        return Areas.getArea(uint256(areaHash) % 5);\\n    }\\n\\n    function areaAt(int32 x, int32 y) public pure returns (Game.Area memory area) {\\n        // TODO\\n        (int32 areaX, int32 areaY) = PositionUtils.area(x, y);\\n        area = computeArea(keccak256(abi.encodePacked(areaX, areaY)));\\n    }\\n\\n    function wallAt(uint128 walls, int32 x, int32 y) internal pure returns (bool) {\\n        uint8 xx = PositionUtils.areaLocalCoord(x);\\n        uint8 yy = PositionUtils.areaLocalCoord(y);\\n        uint8 i = yy * uint8(int8(PositionUtils.AREA_SIZE)) + xx;\\n        return ((walls >> (127 - i)) & 0x1) == 1;\\n    }\\n\\n    function isValidMove(int32 x, int32 y, int32 nextX, int32 nextY) internal pure returns (Game.Reason reason) {\\n        if (nextX == x) {\\n            if ((nextY == y + 1)) {\\n                // TODO cache area, detect area change and update accordingly\\n                Game.Area memory area = areaAt(x, y);\\n                if (wallAt(area.southWalls, x, y)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else if (nextY == y - 1) {\\n                Game.Area memory area = areaAt(nextX, nextY);\\n                if (wallAt(area.southWalls, nextX, nextY)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else {\\n                return Game.Reason.NonAdjacent;\\n            }\\n        } else if (nextY == y) {\\n            if ((nextX == x + 1)) {\\n                Game.Area memory area = areaAt(x, y);\\n                if (wallAt(area.eastWalls, x, y)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else if (nextX == x - 1) {\\n                Game.Area memory area = areaAt(nextX, nextY);\\n                if (wallAt(area.eastWalls, nextX, nextY)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else {\\n                return Game.Reason.NonAdjacent;\\n            }\\n        }\\n        return Game.Reason.NonAdjacent;\\n    }\\n}\\n\",\"keccak256\":\"0xb0d5a865c33836b93095558f4b81bfce8f760ae2c308e036b8ed63d39a5f9972\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/data/Areas.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\n\\nlibrary Areas {\\n    function getArea(uint256 i) internal pure returns (Game.Area memory area) {\\n        if (false) {} else if (i == 0) {\\n            /*\\n .   .   .   . | . | .   .   .   .   .   . |\\n                                            \\n .   .   .   . | . | .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   . | . | .   .   .   .   .   . |\\n                    ___ ___ ___     ___ ___ \\n .   .   .   . | .   .   . | .   .   .   . |\\n___ ___ ___ ___                             \\n .   .   .   .   .   .   . | .   .   .   . |\\n    ___ ___     ___                         \\n . | .   .   .   . | .   . | .   .   .   .  \\n                                            \\n . | .   .   .   . | .   . | .   .   .   . |\\n                            ___ ___ ___ ___ \\n . | .   .   .   . | .   .   .   .   .   . |\\n___                                         \\n .   .   .   .   . | .   .   .   .   .   . |\\n                                            \\n .   .   .   .   . | .   .   .   .   .   . |\\n___ ___ ___ ___ ___ ___ ___     ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 1159363697933213752560450432,\\n                eastWalls: 32083283461873728278639673345225007232\\n            });\\n        } else if (i == 1) {\\n            /*\\n .   .   .   .   . | .   .   .   .   . | . |\\n                                            \\n .   .   .   .   . | .   .   .   .   . | .  \\n___     ___ ___ ___                         \\n .   .   .   . | .   .   .   .   .   . | . |\\n                                            \\n .   .   .   . | . | .   .   .   .   . | . |\\n                                            \\n .   .   .   . | . | .   .   .   .   . | . |\\n                    ___ ___ ___ ___ ___     \\n .   .   .   . | .   .   .   . | .   .   . |\\n___ ___     ___ ___ ___ ___                 \\n .   . | . | .   .   .   . | .   .   .   . |\\n            ___ ___ ___ ___                 \\n .   . | .   .   .   .   .   . | .   .   . |\\n        ___ ___     ___ ___ ___ ___     ___ \\n .   .   .   .   .   . | .   .   .   .   . |\\n                                            \\n .   .   .   .   .   . | .   .   .   .   . |\\n                                            \\n .   .   .   .   .   . | .   .   .   .   . |\\n___     ___ ___ ___ ___ ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 119422827746894799795367216578494336,\\n                eastWalls: 11137644214052370074570601009611280512\\n            });\\n        } else if (i == 2) {\\n            /*\\n .   .   .   .   .   .   .   .   .   .   . |\\n    ___ ___ ___ ___ ___ ___ ___ ___ ___     \\n .   . | .   .   .   .   . | .   .   .   . |\\n___                             ___ ___ ___ \\n . | . | .   .   .   .   .   .   .   .   . |\\n                            ___ ___     ___ \\n . | . | .   .   .   .   . | .   .   .   . |\\n___     ___ ___     ___ ___                 \\n .   .   .   . | .   .   . | .   .   .   . |\\n                                            \\n .   .   .   . | .   .   . | .   .   .   . |\\n                            ___ ___ ___ ___ \\n .   .   .   . | .   .   .   .   .   .   . |\\n                            ___ ___ ___     \\n .   .   .   . | .   .   . | .   .   . | . |\\n                                ___ ___     \\n .   .   .   . | .   .   . | . | .   .   . |\\n                                    ___ ___ \\n .   .   .   . | .   .   . | . | .   .   .  \\n                                ___ ___ ___ \\n .   .   .   . | .   .   .   .   .   .   . |\\n___ ___ ___     ___ ___ ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 169892521661874654557957128099593174912,\\n                eastWalls: 209131995078092551922943393320157312\\n            });\\n        } else if (i == 3) {\\n            /*\\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n___     ___ ___ ___     ___     ___ ___ ___ \\n .   .   .   .   .   .   .   .   .   .   .  \\n___ ___ ___     ___     ___ ___ ___     ___ \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n___ ___ ___ ___ ___     ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 14128568811924974815408000,\\n                eastWalls: 16124762868261372760261637903252467840\\n            });\\n        } else if (i == 4) {\\n            /*\\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   .  \\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n___ ___ ___ ___ ___     ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({southWalls: 257920, eastWalls: 166234668744962605775893174260334720});\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24fbdb2a973acc9f2b1f954c6ff6763d28efe1b49a8fa5409f0c4cb9589adbb7\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/routes/GameCommit.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../GameUtils.sol\\\";\\n\\ncontract GameCommit is Game {\\n    using GameUtils for Config;\\n\\n    struct Context {\\n        uint256 characterID;\\n        address controller;\\n        uint24 epoch;\\n        bytes24 commitmentHash;\\n    }\\n\\n    struct StateChanges {\\n        uint256 characterID;\\n        uint24 epoch;\\n        bytes24 commitmentHash;\\n    }\\n\\n    function commit(uint256 characterID, bytes24 commitmentHash, address payable payee) external payable {\\n        Game.Store storage store = getStore();\\n\\n        Context memory context = _context(store, characterID, commitmentHash);\\n        StateChanges memory stateChanges = computeStateChanges(context);\\n        _apply(store, stateChanges);\\n        emit Game.CommitmentMade(context.characterID, context.controller, context.epoch, context.commitmentHash);\\n\\n        // extra steps for which we do not intend to track via events\\n        if (payee != address(0) && msg.value != 0) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    function computeStateChanges(Context memory context) public pure returns (StateChanges memory stateChanges) {\\n        stateChanges.characterID = context.characterID;\\n        stateChanges.epoch = context.epoch;\\n        stateChanges.commitmentHash = context.commitmentHash;\\n    }\\n\\n    function _context(\\n        Game.Store storage store,\\n        uint256 characterID,\\n        bytes24 commitmentHash\\n    ) internal view returns (Context memory context) {\\n        Game.Config memory config = getConfig();\\n        mapping(address => Game.ControllerType) storage isController = store.characterStates[characterID].controllers;\\n        if (isController[msg.sender] == Game.ControllerType.None) {\\n            revert Game.NotAuthorizedController(msg.sender);\\n        }\\n        context.characterID = characterID;\\n        context.controller = msg.sender;\\n        (context.epoch, ) = config.getEpoch();\\n        context.commitmentHash = commitmentHash;\\n    }\\n\\n    function _apply(Game.Store storage store, StateChanges memory stateChanges) internal {\\n        store.commitments[stateChanges.characterID] = Game.Commitment({\\n            hash: stateChanges.commitmentHash,\\n            epoch: stateChanges.epoch\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x3f7843d7bdea4fddee9a3e45159f76e21fd301660f0111040d4692ae3d4f764f\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/routes/GameEnter.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../GameUtils.sol\\\";\\nimport \\\"../../solidity-kit/solc_0_8/ERC721/interfaces/IERC721Receiver.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract GameEnter is Game, IERC721Receiver {\\n    using GameUtils for Config;\\n\\n    struct Context {\\n        uint256 characterID;\\n        address sender;\\n    }\\n\\n    struct StateChanges {\\n        uint256 characterID;\\n        uint64 position;\\n        address controller;\\n    }\\n\\n    // function mintAndEnter() external {\\n\\n    // }\\n\\n    function enter(uint256 characterID, address payable payee) external payable {\\n        Game.Config memory config = getConfig();\\n\\n        _enter(msg.sender, characterID);\\n\\n        // transfer Character to the game\\n        config.characters.transferFrom(msg.sender, address(this), characterID);\\n\\n        // extra steps for which we do not intend to track via events\\n        if (payee != address(0) && msg.value != 0) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    function computeStateChanges(Context memory context) public pure returns (StateChanges memory stateChanges) {\\n        return StateChanges({characterID: context.characterID, position: 0, controller: context.sender});\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        Game.Config memory config = getConfig();\\n        console.log(\\\"onERC721Received\\\");\\n\\n        if (msg.sender == address(config.characters)) {\\n            _enter(from == address(0) ? operator : from, tokenID);\\n        } else {\\n            revert OnlyCharactersAreAccepted();\\n        }\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function _enter(address sender, uint256 characterID) internal {\\n        Game.Store storage store = getStore();\\n        Context memory context = _context(sender, characterID);\\n        StateChanges memory stateChanges = computeStateChanges(context);\\n        _apply(store, stateChanges);\\n        console.log(\\\"EnteredTheGame\\\", context.characterID, stateChanges.controller, stateChanges.position);\\n        emit EnteredTheGame(context.characterID, stateChanges.controller, stateChanges.position);\\n    }\\n\\n    function _context(address sender, uint256 characterID) internal pure returns (Context memory context) {\\n        context.sender = sender;\\n        context.characterID = characterID;\\n    }\\n\\n    function _apply(Game.Store storage store, StateChanges memory stateChanges) internal {\\n        store.characterStates[stateChanges.characterID].controllers[stateChanges.controller];\\n        store.characterStates[stateChanges.characterID].position = stateChanges.position;\\n    }\\n}\\n\",\"keccak256\":\"0xf4c19d60eddc6004fb70f8fb4a3fc9dd4dc9d33a86dd5198f57de978282dcd91\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/routes/GameLeave.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../GameUtils.sol\\\";\\n\\ncontract GameLeave is Game {\\n    using GameUtils for Config;\\n\\n    struct Context {\\n        uint256 characterID;\\n        uint64 position;\\n        address controller;\\n    }\\n\\n    function leave(uint256 characterID, address to) external {\\n        Game.Store storage store = getStore();\\n        Game.Config memory config = getConfig();\\n\\n        Context memory context = _context(store, characterID);\\n        if (context.position != 0) {\\n            revert UnableToExitFromThisPosition(context.position);\\n        }\\n\\n        emit LeftTheGame(context.characterID, context.controller, context.position);\\n\\n        // transfer Character back to the player\\n        config.characters.safeTransferFrom(address(this), to, characterID);\\n    }\\n\\n    function _context(Game.Store storage store, uint256 characterID) internal view returns (Context memory context) {\\n        mapping(address => Game.ControllerType) storage isController = store.characterStates[characterID].controllers;\\n        if (isController[msg.sender] == Game.ControllerType.None) {\\n            revert Game.NotAuthorizedController(msg.sender);\\n        }\\n        context.controller = msg.sender;\\n        context.characterID = characterID;\\n        context.position = store.characterStates[characterID].position;\\n    }\\n}\\n\",\"keccak256\":\"0x4163a4e90af287ffaba4c55eb580992a4b6170e8bf55442c20bcb2ac8291a3e0\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/routes/GameReveal.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../GameUtils.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\nimport \\\"../../solidity-kit/solc_0_8/utils/Math.sol\\\";\\n\\ncontract GameReveal is Game {\\n    using GameUtils for Config;\\n\\n    struct Context {\\n        uint256 characterID;\\n        uint64 priorPosition;\\n        address controller;\\n        uint24 epoch;\\n        Game.Action[] actions;\\n        bytes32 secret;\\n    }\\n\\n    struct Monster {\\n        int32 x;\\n        int32 y;\\n        uint8 hp;\\n        uint8 kind;\\n    }\\n\\n    struct Battle {\\n        uint8 monsterIndexPlus1; // 0 means no monster\\n        uint8 cardsUsed1; // bitmap\\n        uint8 cardsUsed2; // bitmap\\n    }\\n\\n    struct StateChanges {\\n        uint256 characterID;\\n        uint64 newPosition;\\n        uint24 xp;\\n        uint24 epoch;\\n        uint8 hp;\\n        Monster[5] monsters;\\n        Battle battle;\\n    }\\n\\n    function reveal(uint256 characterID, Game.Action[] calldata actions, bytes32 secret) external {\\n        Game.Store storage store = getStore();\\n        Context memory context = _context(store, characterID, actions, secret);\\n        StateChanges memory stateChanges = computeStateChanges(context, false);\\n        _apply(store, stateChanges);\\n        emit MoveRevealed(\\n            context.characterID,\\n            context.controller,\\n            context.epoch,\\n            context.actions,\\n            stateChanges.newPosition\\n        );\\n    }\\n\\n    function computeStateChanges(\\n        Context memory context,\\n        bool revetOnInvalidMoves\\n    ) public pure returns (StateChanges memory stateChanges) {\\n        stateChanges = initialStateChanges(context);\\n        for (uint256 i = 0; i < context.actions.length; i++) {\\n            _step(stateChanges, context.actions[i], revetOnInvalidMoves);\\n        }\\n    }\\n\\n    function initialStateChanges(Context memory context) public pure returns (StateChanges memory stateChanges) {\\n        uint64 position = context.priorPosition;\\n        (int32 x, int32 y) = PositionUtils.toXY(position);\\n        Monster[5] memory monsters;\\n        // TODO randomize\\n        // TODO explore the idea of persistent local monsters\\n        // they get replaced by new one if out of bound\\n        // we can easily store Monster info in 256 bits?\\n        // position can be represented as delta from player and can be store in few bits this way\\n        // life is tiny and monster type can do the rest\\n        // 256bits should be enough\\n        monsters[0] = Monster({x: x - 2, y: y + 5, hp: 3, kind: 1});\\n        monsters[1] = Monster({x: x - 5, y: y - 3, hp: 3, kind: 1});\\n        monsters[2] = Monster({x: x + 5, y: y + 2, hp: 3, kind: 1});\\n        monsters[3] = Monster({x: x + 6, y: y - 5, hp: 3, kind: 1});\\n        monsters[4] = Monster({x: x + 4, y: y + 8, hp: 3, kind: 1});\\n        stateChanges.monsters = monsters;\\n        stateChanges.newPosition = position;\\n    }\\n\\n    /// @notice allow to step through each action and predict the outcome in turnn\\n    function stepChanges(\\n        StateChanges memory stateChanges,\\n        Game.Action memory action,\\n        bool revetOnInvalidMoves\\n    ) external pure returns (StateChanges memory) {\\n        _step(stateChanges, action, revetOnInvalidMoves);\\n        // as external function, it will always return a copy\\n        return stateChanges;\\n    }\\n\\n    function _context(\\n        Game.Store storage store,\\n        uint256 characterID,\\n        Game.Action[] calldata actions,\\n        bytes32 secret\\n    ) internal view returns (Context memory context) {\\n        Config memory config = getConfig();\\n        // TODO check secret\\n        context.characterID = characterID;\\n        context.priorPosition = store.characterStates[characterID].position;\\n        (context.epoch, ) = config.getEpoch();\\n        context.actions = actions;\\n        context.secret = secret;\\n    }\\n\\n    function _step(\\n        StateChanges memory stateChanges,\\n        Game.Action memory action,\\n        bool revetOnInvalidMoves\\n    ) internal pure {\\n        uint64 position = stateChanges.newPosition;\\n        (int32 x, int32 y) = PositionUtils.toXY(position);\\n        if (stateChanges.battle.monsterIndexPlus1 == 0) {\\n            _move(x, y, stateChanges, action, revetOnInvalidMoves);\\n        } else {\\n            _battle(stateChanges.battle.monsterIndexPlus1 - 1, stateChanges, action, revetOnInvalidMoves);\\n        }\\n    }\\n    function _move(\\n        int32 x,\\n        int32 y,\\n        StateChanges memory stateChanges,\\n        Game.Action memory action,\\n        bool revetOnInvalidMoves\\n    ) internal pure {\\n        uint64 position = stateChanges.newPosition;\\n        Monster[5] memory monsters = stateChanges.monsters;\\n        uint64 next = action.position;\\n        (int32 nextX, int32 nextY) = PositionUtils.toXY(next);\\n        Reason invalidMove = GameUtils.isValidMove(x, y, nextX, nextY);\\n        if (invalidMove == Reason.None) {\\n            position = next;\\n        } else {\\n            if (revetOnInvalidMoves) {\\n                revert InvalidMove(invalidMove);\\n            }\\n        }\\n        (x, y) = PositionUtils.toXY(position);\\n        for (uint256 e = 0; e < 5; e++) {\\n            Monster memory monster = monsters[e];\\n            if (monster.hp > 0) {\\n                int32 m_nextX = monster.x;\\n                int32 m_nextY = monster.y;\\n                int32 xDiff = x - monster.x;\\n                int32 yDiff = y - monster.y;\\n\\n                if (!(xDiff == 0 && yDiff == 0)) {\\n                    if (Math.abs(xDiff) > Math.abs(yDiff)) {\\n                        m_nextX += (xDiff > int32(0) ? int32(1) : int32(-1));\\n                        if (\\n                            GameUtils.isValidMove(monster.x, monster.y, m_nextX, m_nextY) != Reason.None ||\\n                            isTakenByOtherMonster(monsters, m_nextX, m_nextY) != type(uint256).max\\n                        ) {\\n                            m_nextY += (yDiff > int32(0) ? int32(1) : int32(-1));\\n                            m_nextX = monster.x;\\n                            if (\\n                                GameUtils.isValidMove(monster.x, monster.y, m_nextX, m_nextY) != Reason.None ||\\n                                isTakenByOtherMonster(monsters, m_nextX, m_nextY) != type(uint256).max\\n                            ) {\\n                                m_nextY = monster.y;\\n                            }\\n                        }\\n                    } else {\\n                        m_nextY += (yDiff > int32(0) ? int32(1) : int32(-1));\\n                        if (\\n                            GameUtils.isValidMove(monster.x, monster.y, m_nextX, m_nextY) != Reason.None ||\\n                            isTakenByOtherMonster(monsters, m_nextX, m_nextY) != type(uint256).max\\n                        ) {\\n                            m_nextX += (xDiff > int32(0) ? int32(1) : int32(-1));\\n                            m_nextY = monster.y;\\n                            if (\\n                                GameUtils.isValidMove(monster.x, monster.y, m_nextX, m_nextY) != Reason.None ||\\n                                isTakenByOtherMonster(monsters, m_nextX, m_nextY) != type(uint256).max\\n                            ) {\\n                                m_nextX = monster.x;\\n                            }\\n                        }\\n                    }\\n                    monster.x = m_nextX;\\n                    monster.y = m_nextY;\\n                }\\n                if (monster.x == x && monster.y == y) {\\n                    stateChanges.battle.monsterIndexPlus1 = uint8(e + 1); // TODO make e uint8 ?\\n                }\\n            }\\n        }\\n        stateChanges.newPosition = position;\\n    }\\n\\n    function _battle(\\n        uint256 monsterIndex,\\n        StateChanges memory stateChanges,\\n        Game.Action memory action,\\n        bool revetOnInvalidMoves\\n    ) internal pure {}\\n\\n    function isTakenByOtherMonster(\\n        Monster[5] memory monsters,\\n        int32 x,\\n        int32 y\\n    ) internal pure returns (uint256 monsterIndex) {\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (monsters[i].x == x && monsters[i].y == y && monsters[i].hp > 0) {\\n                return i;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    function _apply(Game.Store storage store, StateChanges memory stateChanges) internal {\\n        store.characterStates[stateChanges.characterID].position = stateChanges.newPosition;\\n        store.commitments[stateChanges.characterID].epoch = stateChanges.epoch;\\n    }\\n}\\n\",\"keccak256\":\"0x046208458f2966329942c888690a286dffb2087fc927a6a5ee7476ef3f24d8eb\",\"license\":\"AGPL-3.0-or-later\"},\"src/solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingERC721Events.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165, UsingERC721Events {\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2a5afc2f4e761179de9c718ee807e2d682ed4ae39884906ac333c20282a95d1\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param operator The address which called `safeTransferFrom` function\\n    /// @param from The address which previously owned the token\\n    /// @param tokenID The NFT identifier which is being transferred\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x47e1a42d5906cbc70c15f0352836dc7922d857632075c858f64e6286669a5e2e\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Events {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\",\"keccak256\":\"0x1b0d4ae18443a686be830d3a6ce203d563fe2f42ac9cc3fdf722b702d18152a2\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/utils/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Math {\\n    function abs(int32 x) internal pure returns (int32) {\\n        return x >= 0 ? x : -x;\\n    }\\n}\\n\",\"keccak256\":\"0xa0ac00aea6c81b4aeb57f5c60330d8744f1f0f4846b045c22a1825fc55fd34a4\",\"license\":\"MIT\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n    int32 constant AREA_SIZE = 11;\\n    int32 constant AREA_OFFSET = 5;\\n\\n    function areaCoord(int32 a) internal pure returns (int32 b) {\\n        if (a >= 0) {\\n            b = (a + AREA_OFFSET) / AREA_SIZE;\\n        } else {\\n            b = -((-a + AREA_OFFSET) / AREA_SIZE);\\n        }\\n    }\\n\\n    function areaWorldPoint(int32 areaC) internal pure returns (int32 worldCoord) {\\n        return areaC * AREA_SIZE - AREA_OFFSET;\\n    }\\n\\n    function areaLocalCoord(int32 x) internal pure returns (uint8 index) {\\n        return uint8(uint32(x - (areaCoord(x) * AREA_SIZE - AREA_OFFSET)));\\n    }\\n\\n    function area(int32 x, int32 y) internal pure returns (int32 areaX, int32 areaY) {\\n        areaX = areaCoord(x);\\n        areaY = areaCoord(y);\\n    }\\n\\n    function toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n        x = int32(uint32(position) & 0xFFFFFFFF);\\n        y = int32(uint32(position >> 32));\\n    }\\n\\n    function offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n        x = int32(uint32(position) & 0xFFFFFFFF) + x;\\n        y = int32(uint32(position >> 32)) + y;\\n        newPosition = toPosition(x, y);\\n    }\\n\\n    function toPosition(int32 x, int32 y) internal pure returns (uint64 position) {\\n        position = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n    }\\n}\\n\",\"keccak256\":\"0x8788bccb63c77458a0c10041a421b6bbac539070ba61902b5ebea6b3608a9bb8\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "GameNotStarted()": [
        {
          "notice": "happen when attempting to do something on a game that did not start yet"
        }
      ],
      "NotAuthorizedController(address)": [
        {
          "notice": "happen when an unauthorized account attempt to control a character"
        }
      ],
      "UnableToExitFromThisPosition(uint64)": [
        {
          "notice": "happen when attempting to leave the game from a non-exit position"
        }
      ]
    },
    "events": {
      "CommitmentMade(uint256,address,uint24,bytes24)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "EnteredTheGame(uint256,address,uint64)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "LeftTheGame(uint256,address,uint64)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)": {
        "notice": "A character has its moves revealed and executed"
      }
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x000000000000000000000000dc20d5dad8e15ec3bec3b11d87c846ea7751ddd900000000000000000000000038fda1b0b35bb99e4ac11d8d604cd03e65feb4230000000000000000000000000c17f61b532b4a7f42d1e82a4fd483fdfab3b29c0000000000000000000000004d1431aa2a3eb08c0784b8bf167043bd7e290593000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000077516faf2985322dfff4db9274d9a3d053256d7d",
  "transaction": {
    "hash": "0xc30108cc4579e5de5abe73db2af0a39ce93e0b8da7d9f5148e717cdbf64e5677",
    "nonce": "0x1cf",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0x5fe2500f35626ab1b96e8a572363682b3d42c02bfc9e73fb99ddd67c40305529",
    "blockNumber": "0x5e42b2",
    "transactionIndex": "0x28"
  }
}