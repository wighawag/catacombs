{
  "address": "0x38fda1b0b35bb99e4ac11d8d604cd03e65feb423",
  "abi": [
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum Game.Reason",
          "name": "reason",
          "type": "uint8"
        }
      ],
      "name": "InvalidMove",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "NotAuthorizedController",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyCharactersAreAccepted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "UnableToExitFromThisPosition",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newPosition",
          "type": "uint64"
        }
      ],
      "name": "EnteredTheGame",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "positionWhenLeaving",
          "type": "uint64"
        }
      ],
      "name": "LeftTheGame",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "uint192",
              "name": "action",
              "type": "uint192"
            }
          ],
          "indexed": false,
          "internalType": "struct Game.Action[]",
          "name": "actions",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newPosition",
          "type": "uint64"
        }
      ],
      "name": "MoveRevealed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "characterID",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "leave",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "GameLeave",
  "sourceName": "src/game/routes/GameLeave.sol",
  "bytecode": "0x6080806040523460155761038f908161001a8239f35b5f80fdfe6080604081815260049081361015610015575f80fd5b5f925f3560e01c63f29953b71461002a575f80fd5b3461025a57817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261025a57823592602491823573ffffffffffffffffffffffffffffffffffffffff80821680920361025a5761008883610310565b5f83525f60606020948286820152828982015201527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8036013560f01c36039081019036821161025a576080600282803603810103011261025a57605e908851926100f284610310565b358352601e81013586840152603e81013589840152013590828216820361025a57606001908152865193606085019467ffffffffffffffff95818110878211176102e55789525f8152818101915f8352898201915f83528b5f52600182528a5f20335f52825260ff8b5f20541660038110156102ba571561028c573383528b81528b5f52600182528760018c5f200154168085528061025e57509087867f2bc8caf27920c0130922d6534dcaabc4ab3dc9579ce9f22ae86be323bfcbbee993519451169451168b51908152a3511695863b1561025a5760645f92838851998a9485937f42842e0e000000000000000000000000000000000000000000000000000000008552308a8601528a85015260448401525af1801561025057610215578580f35b909192938095501161022657505052005b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b84513d5f823e3d90fd5b5f80fd5b898b918d51917fe1389181000000000000000000000000000000000000000000000000000000008352820152fd5b8a517fee027da400000000000000000000000000000000000000000000000000000000815233818b01528a90fd5b8a60218b7f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b886041897f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b6080810190811067ffffffffffffffff82111761032c57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffdfea2646970667358221220cd9721d98041d1a1cf703c6242251155c49de45a32447c281c411b9aebf87db464736f6c63430008190033",
  "deployedBytecode": "0x6080604081815260049081361015610015575f80fd5b5f925f3560e01c63f29953b71461002a575f80fd5b3461025a57817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261025a57823592602491823573ffffffffffffffffffffffffffffffffffffffff80821680920361025a5761008883610310565b5f83525f60606020948286820152828982015201527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8036013560f01c36039081019036821161025a576080600282803603810103011261025a57605e908851926100f284610310565b358352601e81013586840152603e81013589840152013590828216820361025a57606001908152865193606085019467ffffffffffffffff95818110878211176102e55789525f8152818101915f8352898201915f83528b5f52600182528a5f20335f52825260ff8b5f20541660038110156102ba571561028c573383528b81528b5f52600182528760018c5f200154168085528061025e57509087867f2bc8caf27920c0130922d6534dcaabc4ab3dc9579ce9f22ae86be323bfcbbee993519451169451168b51908152a3511695863b1561025a5760645f92838851998a9485937f42842e0e000000000000000000000000000000000000000000000000000000008552308a8601528a85015260448401525af1801561025057610215578580f35b909192938095501161022657505052005b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b84513d5f823e3d90fd5b5f80fd5b898b918d51917fe1389181000000000000000000000000000000000000000000000000000000008352820152fd5b8a517fee027da400000000000000000000000000000000000000000000000000000000815233818b01528a90fd5b8a60218b7f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b886041897f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b6080810190811067ffffffffffffffff82111761032c57604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffdfea2646970667358221220cd9721d98041d1a1cf703c6242251155c49de45a32447c281c411b9aebf87db464736f6c63430008190033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "events": {
      "CommitmentMade(uint256,address,uint24,bytes24)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "commitmentHash": "the hash of moves",
          "controller": "account handling the character moves",
          "epoch": "epoch number on which this commit belongs to"
        }
      },
      "EnteredTheGame(uint256,address,uint64)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "newPosition": "the resulting new character's position"
        }
      },
      "LeftTheGame(uint256,address,uint64)": {
        "params": {
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "positionWhenLeaving": "the character's position when leaving"
        }
      },
      "MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)": {
        "params": {
          "actions": "the list of moves made",
          "characterID": "the id of the NFT being played",
          "controller": "account handling the character moves",
          "epoch": "epoch number on which this commit belongs to",
          "newPosition": "the resulting new character's position"
        }
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "182200",
        "executionCost": "233",
        "totalCost": "182433"
      },
      "external": {
        "leave(uint256,address)": "infinite"
      },
      "internal": {
        "_context(struct Game.Store storage pointer,uint256)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Game.Reason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"InvalidMove\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotAuthorizedController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCharactersAreAccepted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"UnableToExitFromThisPosition\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newPosition\",\"type\":\"uint64\"}],\"name\":\"EnteredTheGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"positionWhenLeaving\",\"type\":\"uint64\"}],\"name\":\"LeftTheGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"action\",\"type\":\"uint192\"}],\"indexed\":false,\"internalType\":\"struct Game.Action[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newPosition\",\"type\":\"uint64\"}],\"name\":\"MoveRevealed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"characterID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"leave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"CommitmentMade(uint256,address,uint24,bytes24)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"commitmentHash\":\"the hash of moves\",\"controller\":\"account handling the character moves\",\"epoch\":\"epoch number on which this commit belongs to\"}},\"EnteredTheGame(uint256,address,uint64)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"newPosition\":\"the resulting new character's position\"}},\"LeftTheGame(uint256,address,uint64)\":{\"params\":{\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"positionWhenLeaving\":\"the character's position when leaving\"}},\"MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)\":{\"params\":{\"actions\":\"the list of moves made\",\"characterID\":\"the id of the NFT being played\",\"controller\":\"account handling the character moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"newPosition\":\"the resulting new character's position\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"errors\":{\"GameNotStarted()\":[{\"notice\":\"happen when attempting to do something on a game that did not start yet\"}],\"NotAuthorizedController(address)\":[{\"notice\":\"happen when an unauthorized account attempt to control a character\"}],\"UnableToExitFromThisPosition(uint64)\":[{\"notice\":\"happen when attempting to leave the game from a non-exit position\"}]},\"events\":{\"CommitmentMade(uint256,address,uint24,bytes24)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"EnteredTheGame(uint256,address,uint64)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"LeftTheGame(uint256,address,uint64)\":{\"notice\":\"A character has commited to make a move and reveal it on the reveal phase\"},\"MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)\":{\"notice\":\"A character has its moves revealed and executed\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/routes/GameLeave.sol\":\"GameLeave\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"src/game/Game.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Game.sol\\\";\\nimport \\\"../solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\n\\nabstract contract Game {\\n    // we use constant to bound gas and allow solidity to calulate worst case scenario\\n    uint256 constant MAX_PATH_LENGTH = 256;\\n\\n    /// @notice happen when an unauthorized account attempt to control a character\\n    error NotAuthorizedController(address sender);\\n\\n    /// @notice happen when attempting to leave the game from a non-exit position\\n    error UnableToExitFromThisPosition(uint64 position);\\n\\n    /// @notice happen when attempting to do something on a game that did not start yet\\n    error GameNotStarted();\\n\\n    error OnlyCharactersAreAccepted();\\n\\n    enum Reason {\\n        None,\\n        Wall,\\n        NonAdjacent\\n    }\\n    error InvalidMove(Reason reason);\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of moves\\n    event CommitmentMade(\\n        uint256 indexed characterID,\\n        address indexed controller,\\n        uint24 indexed epoch,\\n        bytes24 commitmentHash\\n    );\\n\\n    /// @notice A character has its moves revealed and executed\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param actions the list of moves made\\n    /// @param newPosition the resulting new character's position\\n    event MoveRevealed(\\n        uint256 indexed characterID,\\n        address indexed controller,\\n        uint24 indexed epoch,\\n        Action[] actions,\\n        uint64 newPosition\\n    );\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param newPosition the resulting new character's position\\n    event EnteredTheGame(uint256 indexed characterID, address indexed controller, uint64 newPosition);\\n\\n    /// @notice A character has commited to make a move and reveal it on the reveal phase\\n    /// @param characterID the id of the NFT being played\\n    /// @param controller account handling the character moves\\n    /// @param positionWhenLeaving the character's position when leaving\\n    event LeftTheGame(uint256 indexed characterID, address indexed controller, uint64 positionWhenLeaving);\\n\\n    struct Commitment {\\n        bytes24 hash;\\n        uint24 epoch;\\n    }\\n\\n    /// @notice Move struct that define the action, type and position\\n    struct Action {\\n        uint64 position;\\n        uint192 action; // TODO define: none, open, attack cards, etc... // TODO make position an action and remove position, first byte define the type: move,\\n    }\\n\\n    enum ControllerType {\\n        None,\\n        Basic,\\n        Owner\\n    }\\n\\n    struct CharacterState {\\n        mapping(address => ControllerType) controllers;\\n        uint64 position;\\n        uint64 epoch;\\n    }\\n\\n    struct Store {\\n        mapping(uint256 => Commitment) commitments;\\n        mapping(uint256 => CharacterState) characterStates;\\n    }\\n\\n    /// @notice Config struct to configure the game instance\\n    struct Config {\\n        uint256 startTime;\\n        uint256 commitPhaseDuration;\\n        uint256 revealPhaseDuration;\\n        IERC721 characters;\\n    }\\n\\n    struct Area {\\n        uint128 eastWalls;\\n        uint128 southWalls;\\n    }\\n\\n    enum MonsterKind {\\n        Basic\\n    }\\n\\n    struct LocalMonster {\\n        MonsterKind kind; // TODO enum\\n        int32 x;\\n        int32 y;\\n        int8 life;\\n    }\\n\\n    function getStore() internal pure returns (Store storage store) {\\n        assembly {\\n            store.slot := 0\\n        }\\n    }\\n\\n    function getConfig() internal pure returns (Config memory config) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        config = abi.decode(msg.data[offset:], (Config));\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(calldatasize(), add(shr(240, calldataload(sub(calldatasize(), 2))), 2))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55b2a039c7de3b6811641d994e35fa6c99dbe3ff5f2beac655666889761a0acd\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/GameUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Game.sol\\\";\\nimport \\\"../utils/PositionUtils.sol\\\";\\nimport \\\"./data/Areas.sol\\\";\\n\\nlibrary GameUtils {\\n    function getEpoch(Game.Config memory config) internal view returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = config.commitPhaseDuration + config.revealPhaseDuration;\\n        uint256 time = block.timestamp; // TODO_timestamp();\\n        if (time < config.startTime) {\\n            revert Game.GameNotStarted();\\n        }\\n        uint256 timePassed = time - config.startTime;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < config.commitPhaseDuration;\\n    }\\n\\n    function computeArea(bytes32 areaHash) public pure returns (Game.Area memory) {\\n        // \\\"made only for 11x11\\\"\\n        assert(PositionUtils.AREA_SIZE == 11);\\n        return Areas.getArea(uint256(areaHash) % 5);\\n    }\\n\\n    function areaAt(int32 x, int32 y) public pure returns (Game.Area memory area) {\\n        // TODO\\n        (int32 areaX, int32 areaY) = PositionUtils.area(x, y);\\n        area = computeArea(keccak256(abi.encodePacked(areaX, areaY)));\\n    }\\n\\n    function wallAt(uint128 walls, int32 x, int32 y) internal pure returns (bool) {\\n        uint8 xx = PositionUtils.areaLocalCoord(x);\\n        uint8 yy = PositionUtils.areaLocalCoord(y);\\n        uint8 i = yy * uint8(int8(PositionUtils.AREA_SIZE)) + xx;\\n        return ((walls >> (127 - i)) & 0x1) == 1;\\n    }\\n\\n    function isValidMove(int32 x, int32 y, int32 nextX, int32 nextY) internal pure returns (Game.Reason reason) {\\n        if (nextX == x) {\\n            if ((nextY == y + 1)) {\\n                // TODO cache area, detect area change and update accordingly\\n                Game.Area memory area = areaAt(x, y);\\n                if (wallAt(area.southWalls, x, y)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else if (nextY == y - 1) {\\n                Game.Area memory area = areaAt(nextX, nextY);\\n                if (wallAt(area.southWalls, nextX, nextY)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else {\\n                return Game.Reason.NonAdjacent;\\n            }\\n        } else if (nextY == y) {\\n            if ((nextX == x + 1)) {\\n                Game.Area memory area = areaAt(x, y);\\n                if (wallAt(area.eastWalls, x, y)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else if (nextX == x - 1) {\\n                Game.Area memory area = areaAt(nextX, nextY);\\n                if (wallAt(area.eastWalls, nextX, nextY)) {\\n                    return Game.Reason.Wall;\\n                } else {\\n                    return Game.Reason.None;\\n                }\\n            } else {\\n                return Game.Reason.NonAdjacent;\\n            }\\n        }\\n        return Game.Reason.NonAdjacent;\\n    }\\n}\\n\",\"keccak256\":\"0xb0d5a865c33836b93095558f4b81bfce8f760ae2c308e036b8ed63d39a5f9972\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/data/Areas.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\n\\nlibrary Areas {\\n    function getArea(uint256 i) internal pure returns (Game.Area memory area) {\\n        if (false) {} else if (i == 0) {\\n            /*\\n .   .   .   . | . | .   .   .   .   .   . |\\n                                            \\n .   .   .   . | . | .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   . | . | .   .   .   .   .   . |\\n                    ___ ___ ___     ___ ___ \\n .   .   .   . | .   .   . | .   .   .   . |\\n___ ___ ___ ___                             \\n .   .   .   .   .   .   . | .   .   .   . |\\n    ___ ___     ___                         \\n . | .   .   .   . | .   . | .   .   .   .  \\n                                            \\n . | .   .   .   . | .   . | .   .   .   . |\\n                            ___ ___ ___ ___ \\n . | .   .   .   . | .   .   .   .   .   . |\\n___                                         \\n .   .   .   .   . | .   .   .   .   .   . |\\n                                            \\n .   .   .   .   . | .   .   .   .   .   . |\\n___ ___ ___ ___ ___ ___ ___     ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 1159363697933213752560450432,\\n                eastWalls: 32083283461873728278639673345225007232\\n            });\\n        } else if (i == 1) {\\n            /*\\n .   .   .   .   . | .   .   .   .   . | . |\\n                                            \\n .   .   .   .   . | .   .   .   .   . | .  \\n___     ___ ___ ___                         \\n .   .   .   . | .   .   .   .   .   . | . |\\n                                            \\n .   .   .   . | . | .   .   .   .   . | . |\\n                                            \\n .   .   .   . | . | .   .   .   .   . | . |\\n                    ___ ___ ___ ___ ___     \\n .   .   .   . | .   .   .   . | .   .   . |\\n___ ___     ___ ___ ___ ___                 \\n .   . | . | .   .   .   . | .   .   .   . |\\n            ___ ___ ___ ___                 \\n .   . | .   .   .   .   .   . | .   .   . |\\n        ___ ___     ___ ___ ___ ___     ___ \\n .   .   .   .   .   . | .   .   .   .   . |\\n                                            \\n .   .   .   .   .   . | .   .   .   .   . |\\n                                            \\n .   .   .   .   .   . | .   .   .   .   . |\\n___     ___ ___ ___ ___ ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 119422827746894799795367216578494336,\\n                eastWalls: 11137644214052370074570601009611280512\\n            });\\n        } else if (i == 2) {\\n            /*\\n .   .   .   .   .   .   .   .   .   .   . |\\n    ___ ___ ___ ___ ___ ___ ___ ___ ___     \\n .   . | .   .   .   .   . | .   .   .   . |\\n___                             ___ ___ ___ \\n . | . | .   .   .   .   .   .   .   .   . |\\n                            ___ ___     ___ \\n . | . | .   .   .   .   . | .   .   .   . |\\n___     ___ ___     ___ ___                 \\n .   .   .   . | .   .   . | .   .   .   . |\\n                                            \\n .   .   .   . | .   .   . | .   .   .   . |\\n                            ___ ___ ___ ___ \\n .   .   .   . | .   .   .   .   .   .   . |\\n                            ___ ___ ___     \\n .   .   .   . | .   .   . | .   .   . | . |\\n                                ___ ___     \\n .   .   .   . | .   .   . | . | .   .   . |\\n                                    ___ ___ \\n .   .   .   . | .   .   . | . | .   .   .  \\n                                ___ ___ ___ \\n .   .   .   . | .   .   .   .   .   .   . |\\n___ ___ ___     ___ ___ ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 169892521661874654557957128099593174912,\\n                eastWalls: 209131995078092551922943393320157312\\n            });\\n        } else if (i == 3) {\\n            /*\\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n___     ___ ___ ___     ___     ___ ___ ___ \\n .   .   .   .   .   .   .   .   .   .   .  \\n___ ___ ___     ___     ___ ___ ___     ___ \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n                                            \\n .   .   .   .   . | . | .   .   .   .   . |\\n___ ___ ___ ___ ___     ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({\\n                southWalls: 14128568811924974815408000,\\n                eastWalls: 16124762868261372760261637903252467840\\n            });\\n        } else if (i == 4) {\\n            /*\\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   .  \\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n                                            \\n .   .   .   .   .   .   .   .   .   .   . |\\n___ ___ ___ ___ ___     ___ ___ ___ ___ ___ \\n\\n*/\\n            area = Game.Area({southWalls: 257920, eastWalls: 166234668744962605775893174260334720});\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24fbdb2a973acc9f2b1f954c6ff6763d28efe1b49a8fa5409f0c4cb9589adbb7\",\"license\":\"AGPL-3.0-or-later\"},\"src/game/routes/GameLeave.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../GameUtils.sol\\\";\\n\\ncontract GameLeave is Game {\\n    using GameUtils for Config;\\n\\n    struct Context {\\n        uint256 characterID;\\n        uint64 position;\\n        address controller;\\n    }\\n\\n    function leave(uint256 characterID, address to) external {\\n        Game.Store storage store = getStore();\\n        Game.Config memory config = getConfig();\\n\\n        Context memory context = _context(store, characterID);\\n        if (context.position != 0) {\\n            revert UnableToExitFromThisPosition(context.position);\\n        }\\n\\n        emit LeftTheGame(context.characterID, context.controller, context.position);\\n\\n        // transfer Character back to the player\\n        config.characters.safeTransferFrom(address(this), to, characterID);\\n    }\\n\\n    function _context(Game.Store storage store, uint256 characterID) internal view returns (Context memory context) {\\n        mapping(address => Game.ControllerType) storage isController = store.characterStates[characterID].controllers;\\n        if (isController[msg.sender] == Game.ControllerType.None) {\\n            revert Game.NotAuthorizedController(msg.sender);\\n        }\\n        context.controller = msg.sender;\\n        context.characterID = characterID;\\n        context.position = store.characterStates[characterID].position;\\n    }\\n}\\n\",\"keccak256\":\"0x4163a4e90af287ffaba4c55eb580992a4b6170e8bf55442c20bcb2ac8291a3e0\",\"license\":\"AGPL-3.0-or-later\"},\"src/solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingERC721Events.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165, UsingERC721Events {\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2a5afc2f4e761179de9c718ee807e2d682ed4ae39884906ac333c20282a95d1\",\"license\":\"MIT\"},\"src/solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Events {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\",\"keccak256\":\"0x1b0d4ae18443a686be830d3a6ce203d563fe2f42ac9cc3fdf722b702d18152a2\",\"license\":\"MIT\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n    int32 constant AREA_SIZE = 11;\\n    int32 constant AREA_OFFSET = 5;\\n\\n    function areaCoord(int32 a) internal pure returns (int32 b) {\\n        if (a >= 0) {\\n            b = (a + AREA_OFFSET) / AREA_SIZE;\\n        } else {\\n            b = -((-a + AREA_OFFSET) / AREA_SIZE);\\n        }\\n    }\\n\\n    function areaWorldPoint(int32 areaC) internal pure returns (int32 worldCoord) {\\n        return areaC * AREA_SIZE - AREA_OFFSET;\\n    }\\n\\n    function areaLocalCoord(int32 x) internal pure returns (uint8 index) {\\n        return uint8(uint32(x - (areaCoord(x) * AREA_SIZE - AREA_OFFSET)));\\n    }\\n\\n    function area(int32 x, int32 y) internal pure returns (int32 areaX, int32 areaY) {\\n        areaX = areaCoord(x);\\n        areaY = areaCoord(y);\\n    }\\n\\n    function toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n        x = int32(uint32(position) & 0xFFFFFFFF);\\n        y = int32(uint32(position >> 32));\\n    }\\n\\n    function offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n        x = int32(uint32(position) & 0xFFFFFFFF) + x;\\n        y = int32(uint32(position >> 32)) + y;\\n        newPosition = toPosition(x, y);\\n    }\\n\\n    function toPosition(int32 x, int32 y) internal pure returns (uint64 position) {\\n        position = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n    }\\n}\\n\",\"keccak256\":\"0x8788bccb63c77458a0c10041a421b6bbac539070ba61902b5ebea6b3608a9bb8\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "errors": {
      "GameNotStarted()": [
        {
          "notice": "happen when attempting to do something on a game that did not start yet"
        }
      ],
      "NotAuthorizedController(address)": [
        {
          "notice": "happen when an unauthorized account attempt to control a character"
        }
      ],
      "UnableToExitFromThisPosition(uint64)": [
        {
          "notice": "happen when attempting to leave the game from a non-exit position"
        }
      ]
    },
    "events": {
      "CommitmentMade(uint256,address,uint24,bytes24)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "EnteredTheGame(uint256,address,uint64)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "LeftTheGame(uint256,address,uint64)": {
        "notice": "A character has commited to make a move and reveal it on the reveal phase"
      },
      "MoveRevealed(uint256,address,uint24,(uint64,uint192)[],uint64)": {
        "notice": "A character has its moves revealed and executed"
      }
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x",
  "transaction": {
    "hash": "0x1873532208eb1351021a3619307a2da8aec26ee9ade389f378c75b9da6d94acb",
    "nonce": "0x1cc",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0xc57e7d7a62256f0cd8c03d2fb75446b60a229175c42477cae008214b6d7ec609",
    "blockNumber": "0x5e42af",
    "transactionIndex": "0x29"
  }
}